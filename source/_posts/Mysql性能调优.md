---
title: 后端Mysql项目优化过程的学习笔记
date: 2023-09-13 14:10:10
---



# 索引的种类

- 按数据结构分类
  1. B+tree索引
  2. Hash索引
  3. Full-text索引：主要用来代替模糊查询，大规模数据的全文搜索一般选择 **Elasticsearch** 实现

- 按物理存储分类
  1. 聚簇索引：InnoDB
  2. 非聚簇索引：MyISAM

- 按字段特性分类
  1. 主键索引（primary key）
  2. 唯一索引（unique）
  3. 普通索引（index）
  4. 全文索引（fulltext）

- 按字段个数分类
  1. 单列索引
  2. 联合索引
     1. [ ] **减少磁盘开销**，建一个联合索引 (a, b, c)，相当于建了 (a)，(a, b)，(a, b, c) 三个索引
     2. [ ] **覆盖索引**
     3. [ ] **效率高**，



# 二级索引

**除主键索引外的所有索引都可以称之为二级索引（阉割版索引）**

在Mysql中主键索引的叶子节点存的是**整行数据**，而二级索引叶子节点内容是**主键的值**

#### 通过二级索引查找数据需要回表



# 索引覆盖

根据索引拿到的内容恰好就是我们需要的内容，这种情况下，不需要回表会进行其它操作，因此称之为**索引覆盖**。在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。这是一种很好的现象，因此

- 在查询操作的时候，尽量不要使用 `select *` 



# 索引下推（ICP）

**作用**：用来在范围查询时减少回表的次数

默认开启，其它的暂时无需过多了解



# 最左前缀原则

**以最左边为起点的**任何连续的索引都能匹配上

如果没有第一列，直接访问第二列，那第二列肯定是无序的，直接访问后面的列就用不到索引了

*例如：当创建 (a, b, c) 联合索引时，想要索引生效只能使用 a 和 ab、abc 三种组合*



# 索引的优缺点

### 优点

1. 提高检索效率
2. 降低排序成本，索引对应的字段是会有一个自动排序功能的，默认为asc

### 缺点

1. 创建和维护索引要消耗时间，这种时间随着数据量的增加而增加
2. 索引需要占用物理空间，数据量越大，占用空间越大
3. 会降低表的增删改的效率，因为每次增删改索引，都需要进行动态维护



# 索引的使用场景

### 适合

1. 较频繁的作为查询条件的字段应该创建索引

### 不适合

1. 字段值的唯一性太差不适合单独做索引
2. 更新非常频繁的字段不适合
3. 不会出现在 where 句中的字段不适合



# Explain语句返回参数解释

| 列名          | 含义                                              |
| ------------- | ------------------------------------------------- |
| id            | 每个select都有一个对应的id号，并且是从1开始自增的 |
| select_type   | 查询语句执行的查询操作类型                        |
| table         | 表名                                              |
| partitions    | 表分区情况                                        |
| type          | 查询所用的访问类型                                |
| possible_keys | 可能用到的索引                                    |
| key           | 实际查询用到的索引                                |
| key_len       | 所使用到的索引长度                                |
| ref           | 使用到索引时，与索引进行等值匹配的列或者常量      |
| rows          | 预计扫描的行数（索引行数或表记录行数）            |
| filtered      | 表示符合查询条件的数据百分比                      |
| Extra         | SQL执行的额外信息                                 |

- **索引效率从高到低**：system > const > eq_ref > ref > fulltext > ref or null > range > index > all，一般来说保证 range 级别，最好能达到 ref 级别



# 索引优化总结

全值匹配我最爱，最左前缀要遵守；

带头大哥不能死，中间兄弟不能断；

索引列上少计算，范围之后全失效；

Like百分写最右，覆盖索引不写星；

不等空值还有or，索引失效要少用；

VAR引号不可丢，SQL高级也不难！



# SQL优化方向

## 避免使用 select *

在表查询中，一律**不要**使用 * 作为查询的字段列表，需要哪些字段必须写明

说明：

1. 增加查询分析器解析成本
2. 增减字段容易与 resultMap 配置不一致
3. 无用字段增加网络消耗，尤其是 text 类型的字段



## 小表驱动大表

用数据量叫嚣、索引比较完备的表，使用其索引和条件对大表进行数据筛选，从而减少数据计算量，提高查询效率。

使用场景：

1. 多表的关联查询，可采用小表驱动大表

底层原理：

​	Join Buffer（连接缓冲区）是优化器用于处理连接查询操作时的临时缓冲区。简单来说当我们需要比较两个或多个表的数据进行 Join 操作时，Join Buffer 可以帮助 Mysql 临时存储结果，以减少磁盘读取和 CPU 负担，提高查询效率。需要注意的是**每个 Join 都有一个单独的缓冲区**。

​	Block nested-loop join（BNL算法）会将驱动表数据加载到 join buffer 里面，然后再批量与被驱动表进行匹配；如果驱动表数据量较大， join buffer 无法一次性装载驱动表的结果集，将会分阶段与被驱动表进行批量数据匹配，会增加被驱动表的扫描次数，从而降低查询效率。因此要遵循**小表驱动大表**的原则。



# 用连接查询代替子查询

*例如 student 表有30条数据，scores 表有80w条数据*

使用子查询：

```sql
ALTER TABLE scores ADD INDEX idx_student_id(student_id);

SELECT
(SELECT student.name FROM student WHERE student.id = scores.student_id),
scores.course_name,
scores.score
FROM scores;
```

使用连接查询：

```sql
SELECT
student.name,
scores.course_name,
scores.score
FROM
student inner JOIN scores ON student,id = scores.student_id;
```

说明：

​	连接查询可以更好地利用索引，提高查询性能。子查询通常会使用临时表或内存表，而连接查询可以直接利用表上的索引。这意味着连接查询可以更快地访问表中的数据，减少查询的资源消耗。
​	对于大型数据集，使用连接查询通常比使用子查询更高效。子查询通常需要扫描整个表，而连接查询可以利用索引加速读取操作。



# 提升group by的效率

如果使用 group by 的列没有索引，那么查询可能会很慢。因此，可以创建一个或多个适当的索引来加速查询。



# 使用limit

作用：

- 提高查询效率：使用 LIMIT 限制返回的数据行数，减轻系统负担，提高查询效率
- 避免过度提取数据：对于大型数据库系统，从数据库中提取大量的数据可能会导致系统崩溃。使用 LIMIT 可以限制提取的数据量，避免过度提取数据，保护系统不受影响
- 优化分页查询：分页查询需要查询所有的数据才能进行分页处理，这会浪费大量的系统资源和时间。使用 LIMIT 优化分页查询可以只查询需要的数据行，缩短查询时间，减少资源浪费
- 简化查询结果：使结果集更加精简

**总得来说，限制行数非常有用，因为它可以提高查询性能、减少处理需要的时间，并且只返回需要的列**

### 对 limit 进行第一次优化

*例如我们需要第1w条后面的10条数据*

那么找前1w条数据，从而定位到这10条数据的过程是浪费的，因此我们可以帮助定位，如：

```sql
select * from table_name where (id>=10000) limit 10;
```

### 对 limit 进行第二次优化

先查出需要数据的索引列（假设为id），再通过索引列查找出需要的数据，如：

```sql
select * from table_name where id in (select id from table_name where (user=xxx)) limit 10000,10;
```

**优化原理**：

1. 子查询只用到了索引列，没有回表操作，所以不涉及磁盘IO，即使是比较大的 offset 查询速度也不会太差
2. 利用子查询的方式，将原来的基于 user 的搜索转化为基于主键的搜索，主查询因为已经获得了准确的索引值，所以查询过程也相对较快

### 对 limit 进行第三次优化

主要是对 **in** 进行优化，使用 **join**

```sql
select * from table_name inner join 
(select id from table_name where (user=xxx) limit 10000, 10) b
using (id);
```



# 用union all 代替union

- union all：获取所有数据但是不去重，包含重复数据
- union：去重



# SQL 改写总的原则

- 减少数据扫描
- 返回更少数据
- 减少交互次数
- 减少服务器CPU及内存开销
