---
title: Java设计模式：简单工厂，工厂方法和抽象工厂
date: 2024-04-15 00:41:30
tags:
- java
- GoF设计模式
categories:
- GoF设计模式
---

# 先说总结！

简单工厂模式，工厂方法模式和抽象工厂模式都是一种建造型方法，它们的核心思想都是**将对象的实例化过程和使用解耦**开来。客户端只需要知道其接口，而无需知道其内部具体的业务逻辑。

简单工厂模式，工厂方法模式和抽象工厂模式，这三种模式的实现是层层递进的，都是依次对前面的补充。

# 简单工厂模式

## 说明

简单工厂模式即在一个工厂类中提供所有的实现类，例如下图所展示的一个鼠标工厂，在这个鼠标工厂中，通过传入一个 `int` 型的实例的代号来获得对应的实例。

![简单工厂模式](./Java设计模式：简单工厂，工厂方法和抽象工厂/简单工厂模式.png)

这种设计方法的缺点很明显：

1. 需要传入一个代号参数指明想要的实例，每次新增实例，都需要对这个工厂类增加相应的业务逻辑；
2. 当系统中的具体产品类不断增多时候，可能会出现要求工厂类根据不同条件创建不同实例的需求．这种对条件的判断和对具体产品类型的判断交错在一起，又增加了系统的维护成本。

# 工厂方法模式

## 说明

工厂方法模式的思想很简单暴力，为每一个产品类都分配一个负责它的实例化过程的工厂，由于每一个产品类都有自己的工厂，因此也就无需在工厂中传入一个参数来区分具体的产品类。在工厂中，只有一个创建对应的产品类的方法，因此叫做**“工厂方法”**。下面是一个演示工厂方法的说明图：

![简单工厂模式](./Java设计模式：简单工厂，工厂方法和抽象工厂/工厂方法模式.png)

在上面的说明图中，所有的鼠标都有一个自己专属的创建工厂，每一个工厂类都有公共的父类。

和简单工厂模式相比，优势之处在于：

1. 创建产品类的时候只需要知道名字即可；
2. 扩展性高，符合开闭原则，新增一个产品类的时候只需要增加一个对应的工厂类，无需修改其他已有的工厂类（**这同时也是其缺点**，因为使得系统中类的数量成倍增长了）。

# 抽象工厂模式

## 说明

抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于**抽象工厂方法里的create有好几个，是一个产品族**，一个抽象工厂创建的是一类产品。下面这张图详细展示了抽象工厂的核心思想：

![简单工厂模式](./Java设计模式：简单工厂，工厂方法和抽象工厂/抽象工厂模式.png)

`PcFacotory` 就是一个抽象工厂，所有生产电脑的工厂类都继承于它，例如图中生产与惠普电脑相关的一系列产品的工厂类和生产与戴尔电脑相关的一系列产品的工厂类。每个工厂只负责同一类产品类的创建。

与工厂方法相比，需要新增产品类的时候只需要修改工厂对应的接口，然后让所有实现了这个接口的工厂类实现其新增的方法即可。大大减少类的数量的同时还提高了代码的可维护性。抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。

其缺点也很明显：增加新的产品等级结构时比较麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码。

# 使用场景

1. Spring 就是一个最大的 Bean 工厂，IoC 通过 FactoryBean 对 Bean 进行管理
2. 我们使用的日志门面框架 slf4j，点进去就可以看到熟悉的味道 `private final static Logger logger = LoggerFactory.getLogger(HelloWord.class);`而这里的工厂实现，通过类加载去获取，应用开发者根本不需要关心背后实现是什么。 项目维护人员维护好日志 jar 包和配置即可
3. JDK 的 Calendar 使用了简单工厂模式 `Calendar calendar = Calendar.getInstance();`
4. 数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。就可以去设计一个工厂类，在类中提供各种数据库的实例对象
