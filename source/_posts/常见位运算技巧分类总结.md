---
title: 常见位运算技巧分类总结
date: 2024-04-28 13:14:22
tags:
- 算法
- 位运算
categories:
- 想成为算法高手
---

> 位运算常用来实现高效率的集合运算，例如用二进制表示一个自然数集合，二进制**从低到高**第 *i* 位为 *1* 表示 *i* 在集合中，为 *0* 表示 *i* 不在集合中。集合 {0, 2, 3} 可以用一个二进制数 1101 表示；反过来，一个二进制数 1101 就表示一个自然数集合 {0, 2, 3} 。在此基础上，就可以利用位运算对集合之间的各种运算进行优化。以这个自然数集合为例总结如下各种位运算的技巧。

# 一. 集合之间的运算

1. **交集** 

代码表示： `a & b`

2. **并集**

代码表示： `a | b`

3. **对称差**

数学上，两个集合的对称差是只属于其中一个集合，而不属于另一个集合的元素组成的集合。 集合论中的这个运算相当于布尔逻辑中的异或运算。

代码表示： `a ^ b`

4. **差**

- 任意两个集合的差：`a & (~b)`

- 如果 *b* 是 *a* 的子集，那么这两个集合的差还可以：`a ^ b`

5. **判断包含关系**

如果 *a* 是 *b* 的子集，那么一定有如下关系：

`a & b = a`

`a | b = b`



# 二. 集合与元素

1. **空集**

`0`

2. **单元素集合**

如果想得到单个元素的集合，例如 *{i}*，那么可以用代码表示为：

`1 << i`

3. **全集**

全集 U = {0, 1, 2, ..., n - 1} 可以表示为：

`(1 << n) - 1`

4. **补集**

给定一个集合 *a*，求 *a* 的补集：

- `~a`
- `((1 << n) - 1) ^ a`

5. **判定元素是否在集合中**

给定一个集合 *a*，如果元素 *i* 在集合中，则有：`(a >> i) & 1 == 1`

如果不在集合中，则有：`(a >> i) & 1 != 1`

6. **向集合中添加元素**

向集合 *a* 中添加自然数 *i*，代码表示如下：

`a | (1 << i)`

7. **删除集合中元素**

将自然数 *i* 从集合 *a* 中删除

如果元素不一定在集合中：`a | ~(1 << i)`

如果元素一定在集合中：`a ^ (1 << i)`

8. **删除集合中的最小元素**

给定一个集合 *a*，删除集合中的最小的元素，代码表示如下：

`a & (a - 1)`

原理解释：

```
      s = 101100
    s-1 = 101011 // 最低位的 1 变成 0，同时 1 右边的 0 都取反，变成 1
s&(s-1) = 101000
```

此外，某些数字可以借助标准库（Java）提供的函数算出：

| 术语                                   | 函数                               |
| -------------------------------------- | ---------------------------------- |
| 集合大小（元素个数）                   | Integer.bitcount(s)                |
| 二进制长度（减一得到集合中的最大元素） | 32-Integer.numberOfLeadingZeros(s) |
| 集合中的最小元素                       | Integer.numberOfTrailingZeros(s)   |

特别地，只包含最小元素的子集，即二进制最低位的 1 及其后面的 0，也叫 **lowbit**，可以用 `a & (-a)` 计算得到，原理如下：

```
     s = 101100
    ~s = 010011
(~s)+1 = 010100 // 根据补码的定义，这就是 -s  =>  s 的最低 1 左侧取反，右侧不变
s & -s = 000100 // lowbit
```



# 三. 遍历集合

给定一个集合 *s*，遍历集合中的每个元素：

```java
for (int i = 0; i < n; i++) {
    if (((s >> i) & 1) == 1) { // i 在 s 中
        // 处理 i 的逻辑
    }
}
```



# 四. 枚举集合

从空集枚举到全集：

```java
for (int s = 0; s < (1 << n); s++) {
    // 处理 s 的逻辑
}
```

设集合为 *s*，从大到小枚举所有非空子集：

```java
for (int sub = s; sub > 0; sub = (sub - 1) & s) {
    // 处理 sub 的逻辑
}
```

**问**：为什么要写成 `sub = (sub - 1) & s` 呢？

**答**：暴力做法是从 *s* 出发，不断减一，直到 0。但这样做，中途会遇到很多并不是 *s* 的子集的情况。例如 *s* = 10101 时，减一得到 10100，这是 *s* 的子集。但再减一就得到 10011 了，这并不是 *s* 的子集，下一个子集应该是  10001。

把所有的合法子集按顺序列出来，会发现我们做的相当于**「压缩版」的二进制减法**，例如

10101 → 10100 → 10001 → 10000 → 00101 → ⋯

如果忽略掉 1*0*1*0*1 中的两个斜体的 0，数字的变化和二进制减法是一样的，即

111 → 110 → 101 → 100 → 011 → ⋯

如何快速找到下一个子集呢？以 
10100 → 10001 为例说明，普通的二进制减法会把最低位的 1 变成 0，同时 1 右边的 0 变成 1，即 
10100 → 10011。「压缩版」的二进制减法也是类似的，把最低位的 1 变成 0，但同时对于 1 右边的 0，只保留在 s = 10101 中的 1，所以是 10100 → 10001。怎么保留？**10101 & 10101** 就行。

如果要从大到小枚举所有的子集（包括空集）：

```java
int sub = s;
do {
    // 处理 sub 的逻辑
    sub = (sub - 1) & s;
} while (sub != s);
```

原理是当 sub = 0 时（空集），再减一就得到 −1，对应的二进制为 111⋯1，再 &s 就得到了 s。所以当循环到 sub = s 时，说明最后一次循环的 sub = 0（空集），s 的所有子集都枚举到了，退出循环。



# 例题

[LeetCode 周赛395场 T3](https://leetcode.cn/problems/minimum-array-end/description/)

清晰的思路可以看灵神的[题解](https://leetcode.cn/problems/minimum-array-end/solutions/2759113/wei-yun-suan-jian-ji-xie-fa-pythonjavacg-nw8t/)，如有侵犯请告知删除。

```java
class Solution {
    public long minEnd(int n, int x) {
        n--;  // 将n填入x的0空位中
        long ans = x;
        int i = 0, j = 0;  // i指向ans的第i个比特位，j指向n的第j个比特位
        while ((n >> j) > 0) {  // n还没有填完
            if ((ans >> i & 1) == 0) {  // ans的第i个位置为空
                ans |= (long)(n >> j & 1) << i;  // ans第i个位置填入n的第j个位置
                j++;
            }
            i++;
        }
        return ans;
    }
}
```

**lowbit** 优化：

```java
class Solution {
    public long minEnd(int n, int x) {
        n--;
        long ans = x;
        int j = 0;
        for (long t = ~x, lb; (n >> j) > 0; t ^= lb) {
            lb = t & (-t);
            ans |= (n >> j & 1) * lb;
            j++;
        }
        return ans;
    }
}
```

