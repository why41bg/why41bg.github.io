---
title: 缓存实践应用
date: 2024-05-15 10:54:54
tags:
- Java
- 缓存
categories:
---

# 何时使用缓存

在决定缓存一段数据时，需要考虑如下几个问题：

1. **使用缓存数据是否安全？**本质上来说，缓存数据是过期的数据，它是磁盘中真实数据在内存中的快照。像生成订单时商品现价的查询就不适合于使用缓存。使用缓存是否安全取决于对缓存数据时效性的忍受程度。
2. **使用缓存是否有效？**缓存的构建是需要付出一定的代价的，如果使用缓存带来的收益无法抵消构建缓存的花费，那么缓存就是无效的。这种场景常见于那些频繁变更的数据。
3. **数据结构是否适合缓存？** 简单的缓存数据库记录通常足以提供显著的性能优势。但在其他一些时候，数据最好以多条记录组合在一起的格式进行缓存。缓存以简单的键值形式存储，可能还需要以多种不同格式缓存数据记录，以便按记录中的不同属性进行访问。例如 Redis 中的 Hash 数据结构。



# 缓存设计模式

## 惰性缓存

惰性缓存（也称作惰性填充或预留缓存）是最常见的缓存形式。所有良好的缓存策略都应以「惰性」为基础。和其它「惰性」思想一样，其基本思想是仅在应用程序实际请求对象时才填充缓存。

与其他方法相比，这种方法具有以下几个优势：

- 缓存仅包含应用程序实际请求的对象，有助于使缓存大小维持在可管理范围内。新对象仅在需要时添加至缓存。这样，当缓存满时，您可以让所用的引擎移出最少访问的键 (引擎默认行为)，从而被动地管理缓存内存。
- 新缓存节点上线 (例如应用程序扩展时) 时，惰性填充方法会在应用程序首次请求对象时将这些对象自动添加至新缓存节点。
- 缓存过期很容易处理：只需删除缓存的对象，下次请求新对象时，从数据库获取对象。

当然，这种方式也存在缺点：

- 第一台节点上线时，可能需要构建大量缓存，这将可能导致数据库崩溃。

只要应用程序符合“经常读取但很少写入数据”的模式，就应该采用惰性缓存策略。例如，在典型的 Web 或移动应用程序中，用户个人资料很少发生变化，但需要在应用程序的许多地方访问。用户一年可能只更新个人资料几次，但根据用户类型，其个人资料每天可能要被访问几十甚至上百次。如果设置了移出策略，流行的缓存技术 (例如 Memcached、Redis 等) 会自动移出不常使用的缓存键以释放内存。因此，自由地应用惰性缓存，这几乎没有缺点。

## 直写

在直写缓存中，缓存在数据库更新时实时更新。这是一种主动更新缓存的策略，对于那些提前知道可能会被大量访问的数据来说，使用直写缓存就可以主动避免缓存未命中的情况发生。

与惰性填充相比，直写有一定优势：

- 它主动避免了缓存未命中，可帮助应用程序更好、更快捷地运行。
- 它将一切应用程序延迟提前到用户更新数据时，更符合用户预期。相比之下，一系列缓存未命中会给用户留下应用程序运行缓慢的印象。
- 它简化了缓存过期。缓存始终是最新的。

但是，直写缓存也有一些缺点：

- 可能会向缓存中填充一些实际上访问不到的多余对象。这不仅占用了额外的内存，而且未用到的项目还可能将更有用的项目「驱逐」出缓存（在其他领域已经有了一些相关的改进手段）。
- 如果某些记录反复更新，可能导致大量缓存改动。这个时候就需要考虑缓存的有效性了。
- 缓存节点出现故障时，缓存中的这些对象都将丢失。需要通过某种方法 (例如惰性填充) 将缺失对象重新填充至缓存。

显然，惰性缓存与直写缓存可以结合使用，以帮助解决上述问题，因为它们与数据流的两端相关联。惰性缓存由客户端触发构建，负责捕获缓存未命中情况，直写缓存由服务端触发构建，在新数据写入时填充缓存，因此这两种方法是相辅相成的。有鉴于此，最好的做法通常是使用惰性缓存作为整个应用程序的基础，在特定情况下将直写缓存用作有针对性的优化手段。



# 缓存到哪里

## 本地缓存

本地缓存（又可以称为机上缓存）即在进程内存中进行数据的缓存，实施起来更加快速容易，只需做少量的工作即可获得明显的改善，其最大的优点是服务和缓存在同一个进程内部，请求缓存非常快速，没有过多的网络开销等；同时，它的缺点也是因为缓存跟应用程序耦合，多个应用程序无法直接的共享缓存，各应用或集群的各节点都需要维护自己的单独缓存，对内存是一种浪费，也会导致缓存一致性问题。

机上缓存通常是在识别缓存需求之后实施和评估的首选方法。通常将数据以内存中哈希表的形式实施机上缓存，通过应用程序逻辑（例如，在完成服务调用后将结果明确放入缓存中）进行托管，或嵌入到服务客户端（例如，使用缓存 HTTP 客户端）中。

尽管本地缓存具有诸多优势并且非常简单，但仍存在一些缺点。

1. 各个服务器中的已缓存数据不一致将缓存一致性问题。如果客户端重复发起调用，他们得到的数据可能不一致，这取决于哪台服务器来处理请求。
2. 下游负载现在与服务的队列大小成比例，这就有可能导致系统的负载能力不够。
3. 内存中缓存还容易受到「冷启动」问题的影响。如果新服务器启动时缓存完全为空，则会出现这些问题。空缓存会导致从属服务填充缓存时，向该从属服务发出的请求激增。

## 外部缓存

外部缓存将数据缓存到独立的空间中，例如使用 Redis，其最大的优点是自身就是一个独立的应用，与本地应用隔离，多个应用可直接共享缓存，这也就解决了各个服务器之间的缓存一致性问题。但是外部缓存与数据源之间的缓存一致性问题依然存在。由于外部缓存与下游服务独立开来，因此下游服务的负载能力不受缓存服务大小的影响，缓存服务和下游服务可以分别独立进行扩展。基于此，外部缓存能够提供比内存中的缓存更多的可用存储空间，从而减少因空间限制而导致缓存被移出的情况。

## 使用哪一种

采用本地缓存还是外部缓存取决于具体的业务场景，并不是说外部缓存一定优于内部缓存。我在美团一面的时候，面试官就告诉我，不要因为别人都这么做，所以我们也这么做。我们在学校里面，往往都是老师告诉我们要这么做，而我们也应该自己去思考一下为什么要这么做。

我们使用缓存的最终目的始终是**以最小的成本最快的效率达到最优的目的**。



# 参考

> [缓存踩踏与惊群效应](https://cloud.tencent.com/developer/article/1891306)
>
> [缓存挑战与策略](https://aws.amazon.com/cn/builders-library/caching-challenges-and-strategies/)
>
> [缓存那些事——美团技术团队](https://tech.meituan.com/2017/03/17/cache-about.html)
>
> [缓存最佳实践](https://aws.amazon.com/cn/caching/best-practices/)
