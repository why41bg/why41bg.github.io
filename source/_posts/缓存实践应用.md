---
title: 缓存实践应用
date: 2024-05-15 10:54:54
tags:
- Java
- 缓存
categories:
---

# 何时使用缓存

在决定缓存一段数据时，需要考虑如下几个问题：

1. **使用缓存数据是否安全？**本质上来说，缓存数据是过期的数据，它是磁盘中真实数据在内存中的快照。像生成订单时商品现价的查询就不适合于使用缓存。使用缓存是否安全取决于对缓存数据时效性的忍受程度。
2. **使用缓存是否有效？**缓存的构建是需要付出一定的代价的，如果使用缓存带来的收益无法抵消构建缓存的花费，那么缓存就是无效的。这种场景常见于那些频繁变更的数据。
3. **数据结构是否适合缓存？** 简单的缓存数据库记录通常足以提供显著的性能优势。但在其他一些时候，数据最好以多条记录组合在一起的格式进行缓存。缓存以简单的键值形式存储，可能还需要以多种不同格式缓存数据记录，以便按记录中的不同属性进行访问。例如 Redis 中的 Hash 数据结构。



# 缓存设计模式

## 惰性缓存

惰性缓存（也称作惰性填充或预留缓存）是最常见的缓存形式。所有良好的缓存策略都应以「惰性」为基础。和其它「惰性」思想一样，其基本思想是仅在应用程序实际请求对象时才填充缓存。

与其他方法相比，这种方法具有以下几个优势：

- 缓存仅包含应用程序实际请求的对象，有助于使缓存大小维持在可管理范围内。新对象仅在需要时添加至缓存。这样，当缓存满时，您可以让所用的引擎移出最少访问的键 (引擎默认行为)，从而被动地管理缓存内存。
- 新缓存节点上线 (例如应用程序扩展时) 时，惰性填充方法会在应用程序首次请求对象时将这些对象自动添加至新缓存节点。
- 缓存过期很容易处理：只需删除缓存的对象，下次请求新对象时，从数据库获取对象。

当然，这种方式也存在缺点：

- 第一台节点上线时，可能需要构建大量缓存，这将可能导致数据库崩溃。

只要应用程序符合“经常读取但很少写入数据”的模式，就应该采用惰性缓存策略。例如，在典型的 Web 或移动应用程序中，用户个人资料很少发生变化，但需要在应用程序的许多地方访问。用户一年可能只更新个人资料几次，但根据用户类型，其个人资料每天可能要被访问几十甚至上百次。如果设置了移出策略，流行的缓存技术 (例如 Memcached、Redis 等) 会自动移出不常使用的缓存键以释放内存。因此，自由地应用惰性缓存，这几乎没有缺点。

## 直写

在直写缓存中，缓存在数据库更新时实时更新。这是一种主动更新缓存的策略，对于那些提前知道可能会被大量访问的数据来说，使用直写缓存就可以主动避免缓存未命中的情况发生。

与惰性填充相比，直写有一定优势：

- 它主动避免了缓存未命中，可帮助应用程序更好、更快捷地运行。
- 它将一切应用程序延迟提前到用户更新数据时，更符合用户预期。相比之下，一系列缓存未命中会给用户留下应用程序运行缓慢的印象。
- 它简化了缓存过期。缓存始终是最新的。

但是，直写缓存也有一些缺点：

- 可能会向缓存中填充一些实际上访问不到的多余对象。这不仅占用了额外的内存，而且未用到的项目还可能将更有用的项目「驱逐」出缓存（在其他领域已经有了一些相关的改进手段）。
- 如果某些记录反复更新，可能导致大量缓存改动。这个时候就需要考虑缓存的有效性了。
- 缓存节点出现故障时，缓存中的这些对象都将丢失。需要通过某种方法 (例如惰性填充) 将缺失对象重新填充至缓存。

显然，惰性缓存与直写缓存可以结合使用，以帮助解决上述问题，因为它们与数据流的两端相关联。惰性缓存由客户端触发构建，负责捕获缓存未命中情况，直写缓存由服务端触发构建，在新数据写入时填充缓存，因此这两种方法是相辅相成的。有鉴于此，最好的做法通常是使用惰性缓存作为整个应用程序的基础，在特定情况下将直写缓存用作有针对性的优化手段。

