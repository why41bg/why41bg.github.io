---
title: 二分查找专题
date: 2024-04-18 11:31:35
tags:
- 算法
---

> **“二分的关键不在于区间里的元素具有什么性质，而是区间外面的元素具有什么性质。”**
>
> 个人觉得理解二分的一个绝妙的例子，LeetCode34：给定一个按非递减排序的数组 `nums` 和一个目标值 `target`，找出数组中最小的大于等于 `target` 的元素的下标和数组中最大的小于等于 `target` 的元素的下标。

**闭区间写法**

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        if (nums.length == 0) return new int[]{-1, -1};
        int[] ret = new int[2];

        // 闭区间写法       
        int left = 0, right = nums.length - 1; 
        while (left <= right) {
            int mid = (right - left) / 2 + left;
            // [0, left) 全都小于 target            
            // (right, n-1] 全都大于等于 target  
            // [left, right] 为未知区间   
            // 最终 left 指向第一个大于等于 target 的元素，right 指向第一个小于 target 的元素   
            if (nums[mid] < target) left = mid + 1;  // mid 及 mid 左边所有都是小于 target 的
            else right = mid - 1;  // mid 及 mid 右边的全部都是大于等于 target 的
        }
        if (left == nums.length || nums[left] != target) {
            return new int[]{-1, -1};
        }
        ret[0] = left;
        left = 0;
        right = nums.length - 1;
        while (left <= right) {
            int mid = (right - left) / 2 + left;
            // [0, left) 都是小于等于 target 
            // (right, n-1] 都大于 target
            // 最终 left 指向第一个大于 target 的元素，right 指向最后一个小于等于 target 的元素
            if (nums[mid] <= target) left = mid + 1;  // mid 及 mid 左边所有的都小于等于 target
            else right = mid - 1;  // mid 及 mid 右边的都小于 target
        }
        ret[1] = left - 1;
        return ret;
    }
}
```

**开区间写法**

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        if (nums.length == 0) return new int[]{-1, -1};
        int[] ret = new int[2];
        // 开区间写法
        int left = -1, right = nums.length;
        while (left + 1 < right) {
            int mid = (right - left) / 2 + left;
            // [0, left] 都小于 target
            // [right, n-1] 都大于等于 target
            // 最终 left 指向最大的小于 target 的元素，right 指向第一个小于等于 target 的元素
            if (nums[mid] < target) left = mid;  // mid 和 mid 左边的都小于 target
            else right = mid;  // mid 和 mid 右边的都大于等于 target 
        }
        if (right == nums.length || nums[right] != target) {
            return new int[]{-1, -1};
        }

        ret[0] = right;

        // 找最后一个位置
        left = -1;
        right = nums.length;
        while (left + 1 < right) {
            int mid = (right - left) / 2 + left;
            // [0, left] 小于等于 target
            // [right, n-1] 大于 target 
            // 最终 left 指向最后一个位置，right 指向第一个大于 target 的元素
            if (nums[mid] <= target) left = mid;  // mid 及 mid 左边的都小于等于 target
            else right = mid;  // mid 及 mid 右边的都大于 target
        }
        ret[1] = left;
        return ret;

    }
}
```



> 在 Java 类库中，接口 `NavigableMap` 实现了两个两分的方法，分别用于查找小于等于目标值的最大的元素与大于等于目标值的最小的元素。因此，只要实现了这个接口的类都可以调用这两个 API 来快速完成二分查找，例如 TreeMap 就实现了这个接口。

关于二分这两个接口源码如下：

```java
/**
 * Returns a key-value mapping associated with the greatest key
 * less than or equal to the given key, or {@code null} if there
 * is no such key.
 *
 * @param key the key
 * @return an entry with the greatest key less than or equal to
 *         {@code key}, or {@code null} if there is no such key
 * @throws ClassCastException if the specified key cannot be compared
 *         with the keys currently in the map
 * @throws NullPointerException if the specified key is null
 *         and this map does not permit null keys
 */
Map.Entry<K,V> floorEntry(K key);

/**
 * Returns a key-value mapping associated with the least key
 * greater than or equal to the given key, or {@code null} if
 * there is no such key.
 *
 * @param key the key
 * @return an entry with the least key greater than or equal to
 *         {@code key}, or {@code null} if there is no such key
 * @throws ClassCastException if the specified key cannot be compared
 *         with the keys currently in the map
 * @throws NullPointerException if the specified key is null
 *         and this map does not permit null keys
 */
Map.Entry<K,V> ceilingEntry(K key);
```
