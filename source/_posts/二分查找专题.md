---
title: 二分查找专题
date: 2024-04-18 11:31:35
tags:
- 算法
---

> 给定一个按非递减排序的数组 `nums` 和一个目标值 `target`，找出数组中第一个等于目标值的元素的下标和最后一个等于目标值的元素的下标。

1. 找到第一个等于目标值的元素的下标

假设第一个等于目标值的元素的下标为 *i*，那么 *[0, i - 1]* 中的所有元素都是小于 `target` 的，*[i, nums.length - 1]* 中的所有元素都是大于等于 `target` 的。

因此，如果 `nums[mid] < target` ，那么 `target` 应该在区间 *[mid + 1, right]* 中，则有 `left = mid + 1`。反之 `target` 应该在区间 *[left, mid]* 中，则有 `right = mid`。

2. 找到最后一个等于目标值的元素的下标

假设最后一个等于目标值的元素的下标为 *i*，那么 *[0, i ]* 中的所有元素都是小于等于 `target` 的，*[i + 1, nums.length - 1]* 中的所有元素都是大于 `target` 的。

因此，如果 `nums[mid] > target` ，那么 `target` 应该在区间 *[left,mid - 1]* 中，则有 `right = mid - 1`。反之 `target` 应该在区间 *[mid, right]* 中，则有 `left = mid`。



> 在 Java 类库中，接口 `NavigableMap` 实现了两个两分的方法，分别用于查找小于等于目标值的最大的元素与大于等于目标值的最小的元素。因此，只要实现了这个接口的类都可以调用这两个 API 来快速完成二分查找，例如 TreeMap 就实现了这个接口。

关于二分这两个接口源码如下：

```java
/**
 * Returns a key-value mapping associated with the greatest key
 * less than or equal to the given key, or {@code null} if there
 * is no such key.
 *
 * @param key the key
 * @return an entry with the greatest key less than or equal to
 *         {@code key}, or {@code null} if there is no such key
 * @throws ClassCastException if the specified key cannot be compared
 *         with the keys currently in the map
 * @throws NullPointerException if the specified key is null
 *         and this map does not permit null keys
 */
Map.Entry<K,V> floorEntry(K key);

/**
 * Returns a key-value mapping associated with the least key
 * greater than or equal to the given key, or {@code null} if
 * there is no such key.
 *
 * @param key the key
 * @return an entry with the least key greater than or equal to
 *         {@code key}, or {@code null} if there is no such key
 * @throws ClassCastException if the specified key cannot be compared
 *         with the keys currently in the map
 * @throws NullPointerException if the specified key is null
 *         and this map does not permit null keys
 */
Map.Entry<K,V> ceilingEntry(K key);
```

