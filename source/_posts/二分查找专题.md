---
title: 二分查找专题
date: 2024-04-18 11:31:35
tags:
- 算法
---

> 给定一个按非递减排序的数组 `nums` 和一个目标值 `target`，找出数组中最小的大于等于 `target` 的元素的下标和数组中最大的小于等于 `target` 的下标。

```java
class Solution {
  public void binSearch(int[] nums, int target) {
		int l = 0, r = nums.length - 1;
    while (l <= r) {
      int mid = ((r - l) >> 1) + l;  // 防止加法溢出的写法
      if (nums[mid] < target) l = mid + 1;
      else r = mid - 1;
    }
    System.out.println("最小的大于等于目标值的元素下标：" + l);
    System.out.println("最大的小于等于目标值的元素下标：" + r);
  }
}
```



> 在 Java 类库中，接口 `NavigableMap` 实现了两个两分的方法，分别用于查找小于等于目标值的最大的元素与大于等于目标值的最小的元素。因此，只要实现了这个接口的类都可以调用这两个 API 来快速完成二分查找，例如 TreeMap 就实现了这个接口。

关于二分这两个接口源码如下：

```java
/**
 * Returns a key-value mapping associated with the greatest key
 * less than or equal to the given key, or {@code null} if there
 * is no such key.
 *
 * @param key the key
 * @return an entry with the greatest key less than or equal to
 *         {@code key}, or {@code null} if there is no such key
 * @throws ClassCastException if the specified key cannot be compared
 *         with the keys currently in the map
 * @throws NullPointerException if the specified key is null
 *         and this map does not permit null keys
 */
Map.Entry<K,V> floorEntry(K key);

/**
 * Returns a key-value mapping associated with the least key
 * greater than or equal to the given key, or {@code null} if
 * there is no such key.
 *
 * @param key the key
 * @return an entry with the least key greater than or equal to
 *         {@code key}, or {@code null} if there is no such key
 * @throws ClassCastException if the specified key cannot be compared
 *         with the keys currently in the map
 * @throws NullPointerException if the specified key is null
 *         and this map does not permit null keys
 */
Map.Entry<K,V> ceilingEntry(K key);
```



> 二分的“**关键不在于区间里的元素具有什么性质，而是区间外面的元素具有什么性质**”。也就是看最终左右指针会停在哪里。如果我们要找第一个大于等于 *x* 的位置，那么我就假设 *L* 最终会停在第一个大于等于 *x* 的位置，*R* 停在 *L* 的左边。这样按照上面那句话，可以把循环不变式描述为“*L* 的左边恒小于 *x*，*R* 的右边恒大于等于 *x* ”，这样一来，其他的各种条件就不言自明了。
