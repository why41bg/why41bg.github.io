---
title: xv6中trap的执行流（一）
date: 2023-11-09 13:48:36
tags:
- OS
- XV6
---
> 关于 xv6 中 trap 机制的实现及执行流程，Robert 教授讲得实在是太好了，让我实在不忍心用自己的话记录关于这一节课知识的理解，以防出现任何违背了 Robert 教授原本意愿的地方。因此，本文中记录的绝大多数都是 Robert 教授原话的翻译，只在些许小地方加入了作者自己理解，特别感谢[翻译者](https://github.com/PKUFlyingPig)准确用心的翻译。

# Trap的执行流程

当在 shell 中使用 write 系统调用时，操作系统将从用户态转变为内核态，从而请求内核提供服务。实际上，write 通过执行 ecall 指令来请求系统调用，ecall 指令会切换到具有 supervisor mode 的内核中，这里涉及到的其实就是系统调用方面的知识了。write 的本质其实就是通过 Trap（陷入），用户程序主动将处理器控制权交给操作系统，由操作系统内核提供需要的服务，然后操作系统再将控制权还给用户程序，下图是 write 系统调用的执行流程。

![Trap执行流程](./xv6中trap的执行流（一）/Trap执行流程.png)

# ECALL指令执行前的状态

接下来，Robert 带我们进入了 gdb 的世界中，通过跟踪一个 XV6 的系统调用，来演示上述 Trap 的执行流。我们跟踪的这个系统调用，也就是 shell 将它的提示信息通过 write 系统调用走到操作系统再输出到 console 的过程。首先，用户代码 sh.c 初始化了这一切。

![sh.c的初始化](./xv6中trap的执行流（一）/sh.c的初始化.webp)

上图中选中的行，是一个 write 系统调用，它将“$ ”写入到文件描述符2。接下来打开 gdb 并启动 XV6。作为用户代码的 shell 调用 write 时，实际上调用的是关联到 shell 的一个库函数。你可以查看这个库函数的源代码，在usys.s。

![调用write时实际调用的库函数](./xv6中trap的执行流（一）/调用write时实际调用的库函数.webp)

上面这几行代码就是实际被调用的 write 函数的实现。这是个非常短的函数，它首先将 SYS_write 加载到 a7 寄存器，SYS_write 是常量16。这里告诉内核，我想要运行第16个系统调用，而这个系统调用正好是 write。之后这个函数中执行了 ecall 指令，从这里开始代码执行跳转到了内核。内核完成它的工作之后，代码执行会返回到用户空间，继续执行 ecall 之后的指令，也就是 ret，最终返回到 shell 中。所以 ret 从 write 库函数返回到了 shell 中。

为了展示这里的系统调用，我会在 ecall 指令处放置一个断点，为了能放置断点，我们需要知道 ecall 指令的地址，我们可以通过查看由 XV6 编译过程产生的sh.asm 找出这个地址。sh.asm 是带有指令地址的汇编代码。我这里会在 ecall 指令处放置一个断点，这条指令的地址是 0xde6。

![ecall指令的地址](./xv6中trap的执行流（一）/ecall指令的地址.webp)

现在，我要让 XV6 开始运行。我期望的是 XV6 在 shell 代码中正好在执行 ecall 之前就会停住。完美，从gdb可以看出，我们下一条要执行的指令就是 ecall。不仅如此，我们来检验一下我们真的在我们以为自己在的位置，让我们来打印程序计数器（Program Counter），也正好我们期望在的位置 0xde6。

![PC中存放的是ecall指令地址](./xv6中trap的执行流（一）/PC中存放的是ecall指令地址.png)

我们还可以输入 *info reg* 打印全部32个用户寄存器。

![ecall执行前32个reg的值](./xv6中trap的执行流（一）/ecall执行前32个reg的值.png)

这里有一些数值我们还不知道，也不关心，但是这里的a0，a1，a2是 shell 传递给 write 系统调用的参数。所以a0是文件描述符2；a1是 shell 想要写入字符串的指针；a2是想要写入的字符数。我们还可以通过打印 shell 想要写入的字符串内容，来证明断点停在我们认为它应该停在的位置。

![shell传递给write的参数](./xv6中trap的执行流（一）/shell传递给write的参数.png)

可以看出，输出的确是美元符（$）和一个空格。所以，我们现在位于我们期望所在的 write 系统调用函数中。有一件事情需要注意，上图的寄存器中，程序计数器（pc）和堆栈指针（sp）的地址现在都在距离0比较近的地址，这进一步印证了当前代码运行在用户空间，因为用户空间中所有的地址都比较小。但是一旦我们进入到了内核，内核会使用大得多的内存地址。

系统调用的时间点会有大量状态的变更，其中一个最重要的需要变更的状态，并且在它变更之前我们对它还有依赖的，就是是当前的 page table。我们可以查看STAP 寄存器。

![ecall执行前的SATP寄存器](./xv6中trap的执行流（一）/ecall执行前的SATP寄存器.png)

这里输出的是物理内存地址，它并没有告诉我们有关 page table 中的映射关系是什么，page table 长什么样。但是幸运的是，在QEMU中有一个方法可以打印当前的 page table。从QEMU界面，输入*ctrl a + c*可以进入到QEMU的 console，之后输入 *info mem*，QEMU会打印完整的 page table。

![shell的pgtbl](./xv6中trap的执行流（一）/shell的pgtbl.png)

这是个非常小的 page table，它只包含了6条映射关系。这是用户程序 shell 的 page table，而 shell 是一个非常小的程序，这6条映射关系是有关 shell 的指令和数据，以及一个无效的 page 用来作为 guard page，以防止 shell 尝试使用过多的 stack page。我们可以看出这个 page 是无效的，因为在 attr 这一列它并没有设置 u 标志位（第三行）。attr 这一列是 PTE 的标志位，第三行的标志位是 rwx 表明这个 page 可以读，可以写，也可以执行指令。之后的是 u 标志位，它表明PTE_u 标志位是否被设置，用户代码只能访问 u 标志位设置了的 PTE。再下一个标志位我也不记得是什么了（这个标志位是 Global ）。再下一个标志位是 a（Accessed），表明这条 PTE 是不是被使用过。再下一个标志位d（Dirty）表明这条 PTE 是不是被写过。

现在，我们有了这个小小的 page table。顺便说一下，最后两条PTE的虚拟地址非常大，非常接近虚拟地址的顶端，如果你读过了 XV6 的书（我在另外一篇记录 Lab3-pgtbl 的实验的博客中给出了用户进程的地址空间结构图），你就知道这两个page 分别是 trapframe page 和 trampoline page。你可以看到，它们都没有设置 u 标志，所以用户代码不能访问这两条 PTE。一旦我们进入到了 supervisor mode，我们就可以访问这两条 PTE 了。

对于这里 page table，有一件事情需要注意：它并没有包含任何内核部分的地址映射，这里既没有对于 kernel data 的映射，也没有对于 kernel 指令的映射。除了最后两条 PTE，这个 page table 几乎是完全为用户代码执行而创建，所以它对于在内核执行代码并没有直接特殊的作用。

下面是 Robert 教授与他的学生的对话。

> 学生提问：PTE 中 a 标志位是什么意思？（了解过操作系统虚拟内存有关策略的话很好理解这位同学的问题）
>
> Robert 教授：这表示这条 PTE 是不是被代码访问过，是不是曾经有一个被访问过的地址包含在这个 PTE 的范围内。d 标志位表明是否曾经有写指令使用过这条 PTE。这些标志位由硬件维护以方便操作系统使用。对于比 XV6 更复杂的操作系统，当物理内存吃紧的时候，可能会通过将一些内存写入到磁盘来，同时将相应的 PTE 设置成无效，来释放物理内存 page。你可以想到，这里有很多策略可以让操作系统来挑选哪些 page 可以释放。我们可以查看 a 标志位来判断这条 PTE 是否被使用过，如果它没有被使用或者最近没有被使用，那么这条 PTE 对应的 page 适合用来保存到磁盘中。类似的，d 标志位告诉内核，这个page 最近被修改过。不过 XV6 没有这样的策略。

接下来，我会在Shell中打印出write函数的内容。

![write函数中的内容](./xv6中trap的执行流（一）/write函数中的内容.png)

程序计数器现在指向 ecall 指令，我们接下来要执行 ecall 指令。现在我们还在用户空间，但是马上我们就要进入内核空间了。

# ECALL指令执行后的状态

现在我执行 ecall 指令（但是我们并不能在 gdb 中看到 ecall 指令执行的过程，ecall 是CPU的指令，自然在gdb中看不到具体内容），第一个问题，执行完了 ecall 之后我们现在在哪？我们可以打印程序计数器（Program Counter）来查看。

![执行ecall后PC的值](./xv6中trap的执行流（一）/执行ecall后PC的值.png)

可以看到程序计数器的值变化了，之前我们的程序计数器还在一个很小的地址 0xde6，但是现在在一个大得多的地址。我们还可以查看 page table，如果我们在 QEMU 中执行 info mem 来查看当前的 page table，可以看到，还是与之前完全相同的 page table，所以 page table没有改变。

根据现在的程序计数器，代码正在 trampoline page 的最开始，这是用户内存中一个非常大的地址。所以现在我们的指令正运行在内存的 trampoline page 中。我们可以来查看一下现在将要运行的指令。

![trampolinePage中的内容](./xv6中trap的执行流（一）/trampolinePage中的内容.png)

这些指令是内核在 supervisor mode 中将要执行的最开始的几条指令，也是在 trap 机制中最开始要执行的几条指令。因为 gdb 有一些奇怪的行为，我们实际上已经执行了位于 trampoline page 最开始的一条指令（注，也就是csrrw指令），我们将要执行的是第二条指令。

我们也可以查看寄存器（图就不给出了），对比 ecall 执行执行前32个寄存器的值可以看出，寄存器的值并没有改变，这里还是用户程序拥有的一些寄存器内容。**所以，现在寄存器里面还都是用户程序的数据，并且这些数据也还只保存在这些寄存器中，所以我们需要非常小心，在将寄存器数据保存在某处之前，我们在这个时间点不能使用任何寄存器，否则的话我们是没法恢复寄存器数据的。如果内核在这个时间点使用了任何一个寄存器，内核会覆盖寄存器内的用户数据，之后如果我们尝试要恢复用户程序，我们就不能恢复寄存器中的正确数据，用户程序的执行也会相应的出错。**

>学生提问：我想知道 csrrw 指令是干什么的？
>
>Rebort 教授：我们过几分钟会讨论这部分。但是对于你的问题的答案是，这条指令交换了寄存器 a0 和 sscratch 的内容。这个操作超级重要，它回答了这个问题，内核的 trap 代码如何能够在不使用任何寄存器的前提下做任何操作。这条指令将 a0 的数据保存在了 sscratch 中，同时又将 sscratch 内的数据保存在a0 中。之后内核就可以任意的使用a0寄存器了。

我们现在在这个地址 0x3ffffff000，也就是上面 page table 输出的最后一个 page，这是 trampoline page。我们现在正在 trampoline page 中执行程序，这个page 包含了内核的 trap 处理代码。ecall 并不会切换 page table，这是 ecall 指令的一个非常重要的特点。所以这意味着，trap 处理代码必须存在于每一个 user page table 中。因为 ecall 并不会切换 page table，我们需要在 user page table 中的某个地方来执行最初的内核代码。而这个 trampoline page，是由内核小心的映射到每一个 user page table 中，以使得当我们仍然在使用 user page table 时，内核在一个地方能够执行 trap 机制的最开始的一些指令。

这里的控制是通过 STVEC（Supervisor Trap Vector Base Address Register） 寄存器完成的，这是一个只能在 supervisor mode 下读写的特权寄存器。在从内核空间进入到用户空间之前，内核会设置好 STVEC 寄存器指向内核希望 trap 代码运行的位置。

![STVEC寄存器中的值](./xv6中trap的执行流（一）/STVEC寄存器中的值.png)

所以如你所见，内核已经事先设置好了 STVEC 寄存器的内容为 0x3ffffff000，这就是 trampoline page 的起始位置。STVEC 寄存器的内容，就是在 ecall 指令执行之后，我们会在这个特定地址执行指令的原因。

最后，我想提示你们，即使 trampoline page 是在用户地址空间的 user page table 完成的映射，**但用户代码不能写它，因为这些 page 对应的 PTE 并没有设置PTE_u 标志位。**这也是为什么 trap 机制是安全的。

我一直在告诉你们我们现在已经在 supervisor mode 了，但是实际上我并没有任何能直接确认当前在哪种 mode 下的方法。不过我的确发现程序计数器现在正在 trampoline page 执行代码，而这些 page 对应的 PTE 并没有设置 PTE_u 标志位。所以现在只有当代码在 supervisor mode 时，才可能在程序运行的同时而不崩溃。所以，我从代码没有崩溃和程序计数器的值推导出我们必然在 supervisor mode。

我们是通过 ecall 走到 trampoline page 的，而 ecall 实际上只会改变三件事情：

第一，ecall 将代码从 user mode 改到 supervisor mode。

第二，ecall 将程序计数器的值保存在了 SEPC（Supervisor Exception Program Counter） 寄存器，该寄存器在 trap 的过程中保存程序计数器的值。我们可以通过打印 SEPC 寄存器看到这里的效果
![SEPC寄存器中的值](./xv6中trap的执行流（一）/SEPC寄存器中的值.png)
尽管其他的寄存器还是还是用户寄存器，但是此时的程序计数器明显已经不是用户代码的程序计数器，而是从 STVEC 寄存器拷贝过来的值。

第三，ecall 会跳转到 STVEC 寄存器指向的指令。

所以现在，ecall帮我们做了一点点工作，但是实际上我们离执行内核中的C代码还差的很远。接下来：

- 我们需要保存32个用户寄存器的内容，这样当我们想要恢复用户代码执行时，我们才能恢复这些寄存器的内容。
- 因为现在我们还在 user page table，我们需要切换到 kernel page table。
- 我们需要创建或者找到一个 kernel stack，并将 Stack Pointer 寄存器的内容指向那个 kernel stack。这样才能给C代码提供栈。
- 我们还需要跳转到内核中C代码的某些合理的位置。

但是 ecall 并不会为我们做这里的任何一件事。当然，我们可以通过修改硬件让 ecall 为我们完成这些工作，而不是交给软件来完成。并且，我们也将会看到，在软件中完成这些工作并不是特别简单。所以你现在就会问，为什么 ecall 不多做点工作来将代码执行从用户空间切换到内核空间呢？为什么 ecall 不会保存用户寄存器，或者切换 page table 指针来指向 kernel page table，或者自动的设置 Stack Pointer 指向 kernel stack，或者直接跳转到 kernel 的C代码，而不是在这里运行复杂的汇编代码？

实际上，有的机器在执行系统调用时，会在硬件中完成所有这些工作。但是 RISC-V 并不会，RISC-V 秉持了这样一个观点：ecall 只完成尽量少必须要完成的工作，其他的工作都交给软件完成。这里的原因是，RISC-V 设计者想要为软件和操作系统的程序员提供最大的灵活性，这样他们就能按照他们想要的方式开发操作系统。所以你可以这样想，尽管 XV6 并没有使用这里提供的灵活性，但是一些其他的操作系统用到了。

- 举个例子，因为这里的 ecall 是如此的简单，或许某些操作系统可以在不切换 page table 的前提下，执行部分系统调用。切换 page table 的代价比较高，如果 ecall 打包完成了这部分工作，那就不能对一些系统调用进行改进，使其不用在不必要的场景切换 page table。
- 某些操作系统同时将 user 和 kernel 的虚拟地址映射到一个 page table 中，这样在 user 和 kernel 之间切换时根本就不用切换 page table。对于这样的操作系统来说，如果 ecall 切换了 page table 那将会是一种浪费，并且也减慢了程序的运行。
- 或许在一些系统调用过程中，一些寄存器不用保存，而哪些寄存器需要保存，哪些不需要，取决于于软件，编程语言，和编译器。通过不保存所有的32个寄存器或许可以节省大量的程序运行时间，所以你不会想要 ecall 迫使你保存所有的寄存器。
- 最后，对于某些简单的系统调用或许根本就不需要任何 stack，所以对于一些非常关注性能的操作系统，ecall 不会自动为你完成 stack 切换是极好的。

所以，ecall 尽量的简单可以提升软件设计的灵活性。