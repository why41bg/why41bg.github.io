---
title: 设计模式：装饰模式
date: 2024-05-14 11:25:33
tags:
- Java
- GoF设计模式
categories:
- GoF设计模式
---

# 装饰模式

装饰模式是一种结构型设计模式， 允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。

当对一个类的行为进行增强的时候，传统的采用继承的方式具有如下问题：

1. 继承是静态的。 因此无法在运行时更改已有对象的行为， 只能使用由不同子类创建的对象来替代当前的整个对象。
2. Java 不支持多继承。

在 《Effective Java》中有一条：组合优于继承。即在一个对象中包含指向另一个对象的引用， 并将部分工作委派给引用对象。装饰模式的本质就是组合思想。

封装器是装饰模式的别称， 这个称谓明确地表达了该模式的主要思想。  “封装器” 是一个能与其他 “目标” 对象连接的对象。 封装器包含与目标对象相同的一系列方法（接口相同）， 它会将所有接收到的请求**委派**给目标对象。 但是， 封装器可以在将请求委派给目标前后对其进行处理（注意区分代理模式）， 所以可能会改变最终结果。

那么什么时候一个简单的封装器可以被称为是真正的装饰呢？ 正如之前提到的， 封装器实现了与其封装对象相同的接口。 因此从客户端的角度来看， 这些对象是完全一样的。 封装器中的引用成员变量可以是遵循相同接口的任意对象。 这使得你可以将一个对象放入多个封装器中， 并在对象中添加所有这些封装器的组合行为。

将原始对象进行层层装饰（功能增强）的过程类似于一个栈，与客户端进行交互的对象将是最后一个进入栈中的装饰对象。 由于所有的装饰都实现了与通知基类相同的接口， 客户端的其他代码并不在意自己到底是与 “纯粹” 的通知器对象， 还是与装饰后的通知器对象进行交互。

我们可以使用相同方法来完成其他行为 。 只要所有装饰都遵循相同的接口， 客户端就可以使用任意自定义的装饰来装饰对象。



# 装饰模式结构

![装饰模式结构](./设计模式：装饰模式/装饰模式结构.png)



# 适用场景

1. 在无需修改对象的情况下对对象进行功能增强，或者在运行时为对象额外增加新功能，可以采用装饰模式。
2. 对被 final 修饰的对象进行功能增强。因为 final 修饰的对象不允许继承，只能使用组合的方式添加额外的行为。



# 与其他模式对比

- 适配器能为被封装对象提供不同的接口， 代理模式能为对象提供相同的接口， 装饰则能为对象提供加强的接口。

- 责任链模式和装饰模式的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。

	责任链的管理者可以相互独立地执行一切操作， 还可以随时停止传递请求。 另一方面， 各种装饰类可以在遵循基本接口的情况下扩展对象的行为。 此外， 装饰无法中断请求的传递。

- 装饰模式可让你更改对象的外表，策略模式则让你能够改变其本质。

- 装饰模式和代理模式有着相似的结构， 但是其**意图**却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于代理通常自行管理其服务对象的生命周期， 而装饰的生成则总是由客户端进行控制。



# 装饰模式的识别

由于目标对象和装饰器遵循同一接口， 因此你可用装饰来对对象进行无限次的封装。 结果对象将获得所有封装器叠加而来的行为。实现这一目标的常见手段是以当前类或对象作为装饰类的创建方法或构造函数。
