---
title: 页表的机理及实现
date: 2023-10-30 11:52:14
tags:
- OS
- XV6
---
> 本篇文章以xv6为基础，记录在学习操作系统过程中对页表及其实现机制的理解。操作系统需要在应用程序与应用程序之间、应用程序和内核程序之间提供强隔离性。而页表就提供了一种这样的强隔离性。

# 基础概念介绍

页（page）：**内存管理是以页为单位的**，4096（$2^{12}$，4K，这个大小几乎适用于所有的处理器）字节为一页。所以物理内存是以4096为粒度使用的。一个页在物理内存当中是连续的，不同页在物理内存当中可以是离散的。

# 地址转换过程

对于任何一条带地址的指令，其中的地址应该认为是虚拟内存地址，而不是物理地址。虚拟内存地址仅对其隶属的进程可见，一个进程看不见其它进程的虚拟地址，这就在应用程序之间提供了强隔离性。一条带虚拟地址的指令结果如下图：

![带地址指令结构](/images/带地址指令.png)

CPU在执行一条执行时，首先会将虚拟内存地址发送给内存管理单元（MMU，Memory Management Unit），内存管理单元会将虚拟地址翻译成物理地址。之后这个物理地址会被用来索引物理内存，并从物理内存加载，或者向物理内存存储数据。从CPU的角度来说，一旦MMU打开了，它执行的每条指令中的地址都是虚拟内存地址。

这些虚拟地址到物理地址的映射关系是保存在一张表单中的，暂且将这张表称为地址转换表，这张表也是存放于内存中的。RISC-V中有一个叫做**SATP的寄存器**，这个寄存器就保存了地址转化表在物理内存当中的地址。CPU会将SATP寄存器中的值发送给MMU，MMU就根据这个物理地址找到地址转换表，从而将指令中的虚拟地址转换成物理地址。值得注意的是，MMU在这里做的仅仅只是读取这个表单，然后完成地址转换工作，它并不会保存这个表单（SATP寄存器由内核管理，写SATP寄存器是一条特殊权限指令，这很好理解吧）。

SATP寄存器中保存的地址是物理地址还是虚拟地址呢？答案是物理地址，因为MMU需要根据这个地址找到地址转换表，如果SATP中存放的是虚拟地址，那么还需要另外一种硬件负责将实际的地址转化表的存储位置找到，这就导致一直递归下去了。因此，**SATP寄存器**当中存放的一定是物理地址。

# 页表

到目前位置，这个地址转换表还不能称之为页表，因为它的每一个表项仅仅只是记录了一个虚拟地址到一个物理地址的映射关系。由于这个地址转化表存在于内存当中，如果按照这种记录方式，那么光是存储这个表，就会占满我们的内存，这显然是不可取的。因此，实际情况并不会为每个地址创建一个表项，而是为每一个**page**创建一条表项。采用这种方式后，地址翻译方式就产生了略微变化。在RISC-V中，寄存器有64位，对于一条64位带地址指令来说，前25位是操作码，后面39位是地址码。地址码又分为前27位index，后12位offset（页内偏移）。

![带地址指令结构](/images/带地址指令.png)

地址翻译流程大概为，首先MMU根据SATP寄存器中的地址找到地址转换表，然后根据index找到对应的表项，根据表项中记录的地址（此时为物理地址）在内存中找到对应的物理页，再根据offset找到对应页中的具体的某一字节。这里只需要大概理解地址翻译流程，而不必深究其细节，因为实际情况和这个还是存在一些不同。现在，可以将这个地址转换表称之为页表了。但是，如果采用这种方法建立页表，光是在内存中存储页表还是会导致内存占满。因此，在RISC-V中，实际情况是采用的3级页表。index的前面9位为L2级页表的索引号，中间9位为L1级页表的索引号，最后9位为L0级页表的索引号。

在RISC-V中，物理地址是54位的（64位最高位的10位保留剩下，剩下54位），其中44bit是物理page号（PPN，Physical Page Number），剩下12bit是offset。下面这段话引用自Frans教授和他学生的对话。

>Student：因为这是一个64bit的机器，为什么硬件设计人员本可以用64bit但是却用了56bit？
>
>Frans教授：选择56bit而不是64bit是因为在主板上只需要56根线。

一个页表的大小和页的大小是一样的，为4KB，一个页表项为64位（因为RISC-V中寄存器是64位），即8B。因此，一个页表有 $2^{12} \div 2^{3} = 2^{9}$ 这么多个表项，每一个表项称之为PTE（Page Table Entry），这也解释了为什么每级页表的索引号都只需要9个bit位。下面来描述一下实际情况中，逻辑地址是如何映射到物理地址的。

首先MMU根据SATP寄存器中的值，找到最高一级的页表，这里这个页表只有512个表项（PET），根据index的高9位找到对应的表项，取出其中的64位。这里有一点值得注意，PET的索引号并没有在表中写出来，而是隐含着的，例如第一项的索引号为0，第二项的索引号为1。这时候取出的64为就是L1级页表所在的物理地址，然后根据index中间9位找到L1级页表对应的PET，找到L0级页表，即最后一级页表。根据index最后9位找到L0级页表当中的PET，这时找到的物理地址就指明了物理内存当中的某一页，直接加上offset即可对应的具体的字节。到此，整个逻辑地址到物理地址的翻译就完成了。

![三级页表翻译流程](/images/三级页表翻译流程.png)

从某种程度上来说，3级索引和1级索引是很相似的。3级索引的主要优点是，如果地址空间中大部分地址都没有使用，不必为每一个index准备一个条目。举个例子，如果地址空间只使用了一个 page，4096Bytes。除此之外，没有使用任何其他的地址。那么一共需要多少个PET或者说 Page Table 来映射这个 page 呢？如果使用3级索引，在最高级需要一个页表，中间级需要一个页表，最低一级也需要一个页表，那么一共是 $3 × 512$ 个条目。如果采用1级索引，需要 $2^{27}$ 个条目。采用3级索引所需的空间大大减少了。这是实际上硬件采用这种层次化的3级page directory结构的主要原因。

在地址翻译流程图中可以看到，每个PET占64位，只有中间44位指明了一个物理内存地址，最高的10位是保留位，以便将来扩展使用，最低10是标志位。

1. 第一个标志位是Valid。如果Valid bit位为1，那么表明这是一条合法的PTE，你可以用它来做地址翻译。
2. 下两个标志位分别是Readable和Writable。表明你是否可以读/写这个page。
3. Executable表明你可以从这个page执行指令。
4. User表明这个page可以被运行在用户空间的进程访问。
5. 其他标志位并不是那么重要，他们偶尔会出现，前面5个是重要的标志位。
