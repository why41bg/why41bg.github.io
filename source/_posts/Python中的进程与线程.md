---
title: Python中的进程与线程
date: 2023-10-01 13:02:06
tags:
- Python多线程
- Python多进程
---

> 进程与线程不是开得越多越好。其实在大多数情况下，我们并不需要使用到多进程与多线程。只有理解了进程和线程的本质，我们才能更好地去运用它们。

# 进程与线程的区别

**进程是资源分配的最小单位，线程是CPU调度的最小单位。**

对于没有学习过操作系统的人来说，这句话可能有点抽象。

**掌握合适的抽象😋**是学习计算机的关键。这里引用一个关于进程和线程的绝妙比喻来深入浅出地解释一下：

- 做个简单的比喻：进程=火车，线程=车厢线程在进程下行进（单纯的车厢无法运行）
- 一个进程可以包含多个线程（一辆火车可以有多个车厢）
- 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）
- 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）
- 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）
- 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）
- 进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）
- 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－"互斥锁"
- 进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”

享受了进程和线程带来的便利，那就得付出相应的代价。**进程与线程的创建与切换是需要消耗一定的资源的**，在大多数编程语言中切换线程消耗的资源更少。但是坏消息是，在Python中的多线程是**伪多线程**。



# GIL锁

GIL锁，全称为Global Interpreter Lock，也就是全局解释器锁。是为了解决多线程共享内存的数据安全而设计的。由于Python的运行依赖于Python解释器，GIL锁的存在就保证了解释器每次只能运行一个线程，这就是为什么说Python中的多线程是伪多线程🤔。



# 多进程与多线程的使用场景

- CPU密集型操作使用多进程。因为大多数时间花在CPU上，无需IO（简单地说就是数据已经在内存中，不需要读取磁盘、不需要网络通信），所以希望CPU的利用率越高越好，选择多进程是合适的
- IO密集型操作使用多线程。因为大多数时间花在IO交互的等待上，此时一个CPU和多个CPU是没有太大差别的，反而是线程切换比进程切换要轻量得多，这时候使用多线程是合适的。



# 同步互斥

进程之间（也是线程之间，下面就只描述进程）往往是异步的，各进程按各自独立的、不可预知的速度向前推进，异步性会导致执行结果的不可再现性。因此不同进程对于临界资源的访问需要加以控制，这就是进程间的同步互斥问题。

经典的同步问题有：

1. 生产者-消费者问题
2. 读者-写者问题
3. 哲学家进餐问题



# 进程间通信

进程间是相互独立的，不存在共享内存空间。如果两个进程需要通信，就需要借助一些工具，最常见的就是队列了。

队列常用来解决生产者-消费者问题，生产者进程在一端写入，消费者进程在一段读出。

使用队列完成进程间通信示例代码如下：

```python
# 首先创建两个函数扮演生产者和消费者
def producer(queue):
    for item in range(5):
        queue.put(item)
        print(f"生产者将 {item} 放入队列")
        time.sleep(1)
    
def consumer(queue):
    while True:
        item = queue.get()
        if item == None:
            break
        print(f"消费者将 {item} 读出队列")
        
if __name__ = '__main__':
    from multiprocessing import Process, Queue
    queue = Queue()  # 创建队列对象
    p_fn = Process(target=producer, args=(queue, ))
    c_fn = Process(target=consumer, args=(queue, ))
    p_fn.start()
    c_fn.start()
    p_fn.join()
    queue.put(None)  # 当生产者进程结束后，主进程向队列中发送一个结束标志，消费者进程收到后结束死循环
    c_fn.join()
   	print(f"子进程全部完成，主进程结束")  
```

- 此处有一个额外需要注意点是，Python写进程必须写在main中。因为创建的子进程会自动导入目标函数所在的脚本，如果创建Proces的代码和目标函数的代码写在一起就会导入自己，而导入后，如果没有写在main，就会又创建一个Process，又去导入目标函数所在脚本，这样无限循环。



# 线程间通信

## 锁

与多进程的内存独立不同，多线程间可以共享进程的内存，所以同一个变量是可以被多个线程共享的，不需要额外的工具。**想要让多个线程能同时操作某变量，要么将该变量作为参数传递到线程中（必须是可变变量，例如list和dict），要么作为全局变量在线程中用global关键字进行声明**。

但是，当对全局变量进行写操作的时候，这部分操作需要加锁来保证内存安全。最常见的锁就是**互斥锁**了。

```python
lock = threading.Lock()  # 创建互斥锁
lock.acquire()  # 在对全局变量进行操作之前，加锁
lock.release()  # 对全局变量操作完成之后，释放锁
```

如果线程在进入临界区之前没有获取到锁，该线程就会被阻塞在这里。但是等待锁的过程又会造成大量的时间浪费。因此，我们也可以使用queue来实现线程间的通信。

## Queue

队列使用方法同进程一样，不再赘述。只需要记住的是，**不管是多线程还是多进程，生产者-消费者模型都可以用队列来完成。**

